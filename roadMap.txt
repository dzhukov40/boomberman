---
Ресурсы:

// оф сайт
- игра, которая ляжет в основу [ https://habr.com/post/184666/ ]
- (*) нашел гениальный проект [ http://gameofbombs.com ]


---
элементы документа

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение
[*] - важное контекстное примечание
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку

---
- [boomberman] попробуем замутить бомбермена !! все необходимое должно лежать в одном файле jar !



1) создаем проект
  - создали обычный 'gradle + spring boot' проект
  - важно помнить что 'gradle' имеет кучу плагинов, определяющих как собирать проект
    поэтому у нас стоит плагин -> id 'org.springframework.boot' version '2.0.0.RELEASE'
  - создаем первый контроллер, который убедит нас в том что у нас все запускается
    - EchoController пусть он вернет 'Hello World!' на запрос '/echo'
  - переносим фронт в 'resources/static -> css+img+js'
    - идем на фронт при запущенном приложении, это 'index.html'
    - добавили в проект 'nodeJS' крипт, который запускает сервер для отдачи всей статики
      - запустить сервер [ node debugStaticServer.js ]


2) Делаем общий каркас на фронте нашего приложения
  - на фронте разбиваем код на модули через самовызывающиеся ф-ии
  - правило разбивания
    - один файл это один класс и один модуль
    - имя класса файла и модуля одинаковое
    - модуль при загрузки 'JavaScript' пихает себя в обьект 'window'
    - структура любого модуля

(function () {

    // тут можем определять ф-ии и переменные которые будут закрыты
    // также тут можем подключать другие модули (*) зависимости


    class HttpClient {  // экспортируемый класс
        constructor() {
        }
    }

    window.HttpClient = HttpClient;  // экспортируем класс

})();


3) Делаем все необходимые запросы GET ... POST
  - для работы сервера отладки нало разрешить cros запросы
  - добавим аннотацию в базовый контроллер
  - @CrossOrigin(origins = "http://127.0.0.1:3000")


4) Смотрим внимательно на 'Spring-boot'
  - смотрим лог запуска 'Spring-boot' приложения:
    - [!] сходи посмотри на эти урлики
    - Mapped "{[/actuator/health],methods=[GET] ...
    - Mapped "{[/actuator/info],methods=[GET] ...
    - Mapped "{[/actuator],methods=[GET] ...


5) добавим мапер 'Dozer'
  - url ' http://dozer.sourceforge.net/documentation/gettingstarted.html '
  - добавляем файл 'dozerBeanMapping.xml' описывающий мапинг в 'resources'
  - добавили зависимость в 'build.gradle' строчку 'compile("net.sf.dozer:dozer:${net_sf_dozer_dozer_version}")'


6) добавляем инмемори базу 'h2'
  - добавили в 'resources' папочку 'database'
    - 'shema.sql' создаем таблицы, индексы, вьюхи и так далее
    - 'data-dev.sql' указываем первоначальное запролнение таблиц при запуске приложения
  - добавили зависимость compile("com.h2database:h2:${com_h2database_h2_version}")
  - прописываем настройки 'application.properties'
    -
  - теперь можем при запуске сходить в консоль "http://localhost:8070/h2-console"
  - подсоединились из idea к нашей 'inMemory' базе данных
    - path: http://localhost:8070~/test
    - user: sa
    - url: jdbc:h2:http://localhost:8070~/test

7) добавим спринг мониторинг нашего приложения
  - добавим зависимость:
    - compile("org.springframework.boot:spring-boot-starter-actuator:${org_springframework_boot_spring_boot_starter_actuator}")
  - прописываем настройки 'application.properties'
  - теперь мы можем зайти на:
    - ' http://localhost:8090/actuator '
  - (*) много информации для мониторинга + можно создать свой URL и выводить туда статистику


8) добавляем orm 'hibernate'
  - добавим зависимость:
    - compile("org.hibernate:hibernate-core:${org_hibernate_hibernate_core}")
    - compile("org.springframework.boot:spring-boot-starter-data-jpa:${org_springframework_boot_spring_boot_starter_data_jpa}")
  - начали проставлять аннотации для сущности 'User'
  - с базой будем общаться через супер хитрый интерфейс 'JpaRepository'
  - (+) убрали у интерфейсов 'API' -> добавили реализациям 'Impl'
  - добавили ультра мощную анатацию
    - ' EnableAutoConfiguration ' позволит спрингу из 'application.properties' создавать бины


9) теперь надо прикрутить тестирование
  - добавим зависимость:
    - testCompile("org.springframework.boot:spring-boot-starter-test:${org_springframework_boot_spring_boot_starter_test}")
  - добавили папку 'test' набор пакетов 'ru.doneathome.boomberman'
    - не зобыли папку ресурсов 'resources' (*) туда надо положить текстовый контекст
  - для создания теста мы на написанном класе кликаем ПКМ и выбираем 'go to' потом 'test' и выбираем методы класса и 'ok'
  - [!] тестирование сервисов
    - нужно внутринние инжекты сервисов сделать заглушками моками
      - для этого аннотируем класс @RunWith(MockitoJUnitRunner.class) это разрешит работу @Mock
      - определяем заглушки необходимые аннотацией @Mock
      - инжектим экземпляр класса с применением заклушее и уже его тетируем @InjectMocks
    - в методах теста мы можем использовать метод 'org.mockito.Mockito.when'
      для определения того что МОК должен возвращать
    - создадим класс помошник, для создания необходимых сущностей в тестах 'modelBuilders'


10) добавим утилитарные библиотеки, которые позволяют меньше писать кода
  - добавим зависимость:
    - compile("org.apache.commons:commons-lang3:${org_apache_commons_commons_lang3}")
    - compile("commons-collections:commons-collections:${commons_collections_commons_collections}")


11) добавим авторизацию и аутентификацию
  - добавим зависимость
    - compile("org.springframework.boot:spring-boot-starter-security:${org_springframework_boot_spring_boot_starter_security}")
  - теперь при запуске приложения в логе видим Mapping filter: 'springSecurityFilterChain' to: [/*]
  - + видим в логе [ Using generated security password: dbc3d583-629f-4206-9f6d-6c51b0d41d47 ] (*)
    - это по умолчанию создается пользователь с таким нагенеренном паролем
  - если мы пойдем на сайт? нас будет перекидывать на страницу регистрации http://localhost:8070/login
    - форма ввода Login и Password (*) можем войти как user и нагенеренный пароль
  - переписали немного нашу базу данных и добавили таблицы РОЛИ и таблицу связей РОЛИ-ПОЛЬЗОВАТЕЛИ
  - [-/-]
  - добавляем класс реализующий интерфейс 'UserDetailsService', тут определяем метод получения \
    пользователя из BD и его ролей
  - добавляем класс реализующий 'WebSecurityConfigurerAdapter' там нам нужно переоределить метод для
    получения, важного для нас бина
  - пишем простой сервис по логированию и получению имени залогинненого пользователя SecuretyService
  - [!]
  - роли пользователя храним в базе как строчки с кодом роли, а все варианты кодов будут тут 'RoleType'
  - !!! хранить роли, это не совсем тот подхход который мне нравиться, будем хранить
    права пользователя 'Grant' это маленькие частички разврешающие те или иные действия. Это необходимо
    для очень гипкой системы настройки прав и возможностей пользователя в данный момент.
  - Высунули URL консоли базы данных, добавили исключение, там не надо просить логин и пароль:
    - вот тут конфигурим: 'WebSecurityConfig'
      - http.authorizeRequests().antMatchers("/h2-**").permitAll();
      - http.csrf().disable();
      - http.headers().frameOptions().disable();
  - !!! непонятная багуля с базой h2 пришлось добавить 'select' запрос перед инсертом в каждой таблице
  - вернули в базу сущности роли пользователя, это глобальное распределение всех пользователей по группам,
    - (*) у каждого пользователя может быть уникальный набор прав 'grant'
  - немного разобрались с JWT
    - генерим и возвращаем токен на запрос содержащий логин и пароль зарегестрированного пользователя
    - работает запрос регистрации нового пользователя
    - [!] надо на UI написать функционал, прикрепляющий полученный токен к каждому запросу на бек
  - будем хранить хеши паролей в базе, есть онлайн калькулятор
    - создавали/проверяли тут " https://www.dailycred.com/article/bcrypt-calculator "
    - мы при запросе, который требует аутентификации не попадали на самописный фильтр проверки токена
      поэтому попадали в метод не авторизованного доступа
      - " http.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); "


12) добавим ветку в наш проект (*) аутентификацию делали в отдельной ветке
  - чтобы создать ветку с именем 'auth' выполним 'git checkout -b auth'
  - посмотреть список веток 'git branch'
    - добавляем то что хотим вкомитить 'git add roadMap.txt'
    - сделать коммит 'git commit -m "добавили описание работы с ветками в гите"'
    - сделать push 'git push --set-upstream origin auth' (*) наверно это для первого раза так надо сделать
  - переключиться на мастер ветку 'git checkout master' назад на созданную 'git checkout auth'
  - мерж ветки в мастер 'git merge auth'


13) вернулись к фронту
  - смотрим как нам создавать " canvas "
  - создали главный класс, который будет в себе содежать все рисуемые элементы
  - добавили класс отслеживания нажатых кнопок пользователем
  - создаем класс для кеширования на стороне клиента ресурсов, пока будем там хранить изображения
    - пока сделали тестовое сообщение в консоль после загрузки ресурсов на клиент
  - нашли бесплатные ' Sprites' для бомбермена
    - качаем и оставляем нужное и компануем через ' gimp '
      - в ' gimp ' File -> newImage -> AdvancedOptions -> FillWith:Transparency
      - потом открываем наборы изображений как слои File -> OpenAsLayers
      - сохраняем проект ' gimp ' как ' *.xcf' (*) сохраняем в проекте
      - создаем картинку ' *.png ' File -> Export
    - ' https://gamedevelopment.tutsplus.com/articles/enjoy-these-totally-free-bomberman-inspired-sprites--gamedev-8541 '













[?] как запустить собранное приложение
  - запустить сервер из консольки в проектре [ java -jar ./build/libs/boomberman.jar ]
  - топаем на localhost:8070 - порт проставляется в [ applicapion.properties ]
  - пересобираем и запускаем [ gradle clean build && java -jar ./build/libs/boomberman.jar ]

[?] как запустить nodeJS сервер для фронта
  - запустить сервер [ node debugStaticServer.js ]

[?] как создать свой таск в 'gradle'
  - // создали такс, который можем запустить [ gradle hello ]
    task hello {
            println  "hello world!"
            println  helloString  // вытаскиваем строчку из 'gradle.properties'
    }
